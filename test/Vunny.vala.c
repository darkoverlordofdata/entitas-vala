/* Vunny.vala.c generated by valac 0.34.4, the Vala compiler
 * generated from Vunny.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <stdio.h>
#include <float.h>
#include <math.h>
#include <gobject/gvaluecollector.h>


#define BUNNY_TYPE_VUNNY (bunny_vunny_get_type ())
#define BUNNY_VUNNY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BUNNY_TYPE_VUNNY, BunnyVunny))
#define BUNNY_VUNNY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BUNNY_TYPE_VUNNY, BunnyVunnyClass))
#define BUNNY_IS_VUNNY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BUNNY_TYPE_VUNNY))
#define BUNNY_IS_VUNNY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BUNNY_TYPE_VUNNY))
#define BUNNY_VUNNY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BUNNY_TYPE_VUNNY, BunnyVunnyClass))

typedef struct _BunnyVunny BunnyVunny;
typedef struct _BunnyVunnyClass BunnyVunnyClass;
typedef struct _BunnyVunnyPrivate BunnyVunnyPrivate;

#define BUNNY_TYPE_SHOULD (bunny_should_get_type ())
#define BUNNY_SHOULD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BUNNY_TYPE_SHOULD, BunnyShould))
#define BUNNY_SHOULD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BUNNY_TYPE_SHOULD, BunnyShouldClass))
#define BUNNY_IS_SHOULD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BUNNY_TYPE_SHOULD))
#define BUNNY_IS_SHOULD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BUNNY_TYPE_SHOULD))
#define BUNNY_SHOULD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BUNNY_TYPE_SHOULD, BunnyShouldClass))

typedef struct _BunnyShould BunnyShould;
typedef struct _BunnyShouldClass BunnyShouldClass;

#define BUNNY_TYPE_TEST (bunny_test_get_type ())
#define BUNNY_TEST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BUNNY_TYPE_TEST, BunnyTest))
#define BUNNY_TEST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BUNNY_TYPE_TEST, BunnyTestClass))
#define BUNNY_IS_TEST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BUNNY_TYPE_TEST))
#define BUNNY_IS_TEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BUNNY_TYPE_TEST))
#define BUNNY_TEST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BUNNY_TYPE_TEST, BunnyTestClass))

typedef struct _BunnyTest BunnyTest;
typedef struct _BunnyTestClass BunnyTestClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _bunny_should_unref0(var) ((var == NULL) ? NULL : (var = (bunny_should_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define BUNNY_TYPE_EXPECTATION (bunny_expectation_get_type ())
#define BUNNY_EXPECTATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BUNNY_TYPE_EXPECTATION, BunnyExpectation))
#define BUNNY_EXPECTATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BUNNY_TYPE_EXPECTATION, BunnyExpectationClass))
#define BUNNY_IS_EXPECTATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BUNNY_TYPE_EXPECTATION))
#define BUNNY_IS_EXPECTATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BUNNY_TYPE_EXPECTATION))
#define BUNNY_EXPECTATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BUNNY_TYPE_EXPECTATION, BunnyExpectationClass))

typedef struct _BunnyExpectation BunnyExpectation;
typedef struct _BunnyExpectationClass BunnyExpectationClass;
#define _bunny_test_unref0(var) ((var == NULL) ? NULL : (var = (bunny_test_unref (var), NULL)))
typedef struct _BunnyTestPrivate BunnyTestPrivate;
typedef struct _BunnyParamSpecVunny BunnyParamSpecVunny;
typedef struct _BunnyExpectationPrivate BunnyExpectationPrivate;

#define BUNNY_TYPE_TO (bunny_to_get_type ())
#define BUNNY_TO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BUNNY_TYPE_TO, BunnyTo))
#define BUNNY_TO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BUNNY_TYPE_TO, BunnyToClass))
#define BUNNY_IS_TO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BUNNY_TYPE_TO))
#define BUNNY_IS_TO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BUNNY_TYPE_TO))
#define BUNNY_TO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BUNNY_TYPE_TO, BunnyToClass))

typedef struct _BunnyTo BunnyTo;
typedef struct _BunnyToClass BunnyToClass;
#define _bunny_to_unref0(var) ((var == NULL) ? NULL : (var = (bunny_to_unref (var), NULL)))
typedef struct _BunnyParamSpecExpectation BunnyParamSpecExpectation;
typedef struct _BunnyParamSpecTest BunnyParamSpecTest;
typedef struct _BunnyToPrivate BunnyToPrivate;
#define _bunny_expectation_unref0(var) ((var == NULL) ? NULL : (var = (bunny_expectation_unref (var), NULL)))
typedef struct _BunnyParamSpecTo BunnyParamSpecTo;
typedef struct _BunnyShouldPrivate BunnyShouldPrivate;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _BunnyParamSpecShould BunnyParamSpecShould;

typedef void (*BunnyDelegateTest) (void* user_data);
typedef gboolean (*BunnyDelegateFunc) (void* user_data);
struct _BunnyVunny {
	GTypeInstance parent_instance;
	volatile int ref_count;
	BunnyVunnyPrivate * priv;
	gint passed;
	gint failed;
	gchar* name;
	BunnyShould* should;
	GeeArrayList* tests;
};

struct _BunnyVunnyClass {
	GTypeClass parent_class;
	void (*finalize) (BunnyVunny *self);
};

struct _BunnyTest {
	GTypeInstance parent_instance;
	volatile int ref_count;
	BunnyTestPrivate * priv;
	gchar* name;
	gboolean result;
	gboolean hasReturn;
	BunnyDelegateTest proc;
	gpointer proc_target;
	BunnyDelegateFunc func;
	gpointer func_target;
};

struct _BunnyTestClass {
	GTypeClass parent_class;
	void (*finalize) (BunnyTest *self);
};

struct _BunnyParamSpecVunny {
	GParamSpec parent_instance;
};

struct _BunnyExpectation {
	GTypeInstance parent_instance;
	volatile int ref_count;
	BunnyExpectationPrivate * priv;
	GValue actual;
	BunnyTo* to;
};

struct _BunnyExpectationClass {
	GTypeClass parent_class;
	void (*finalize) (BunnyExpectation *self);
};

struct _BunnyParamSpecExpectation {
	GParamSpec parent_instance;
};

struct _BunnyParamSpecTest {
	GParamSpec parent_instance;
};

struct _BunnyTo {
	GTypeInstance parent_instance;
	volatile int ref_count;
	BunnyToPrivate * priv;
	BunnyExpectation* parent;
	BunnyShould* should;
	gboolean invert;
};

struct _BunnyToClass {
	GTypeClass parent_class;
	void (*finalize) (BunnyTo *self);
};

struct _BunnyParamSpecTo {
	GParamSpec parent_instance;
};

struct _BunnyShould {
	GTypeInstance parent_instance;
	volatile int ref_count;
	BunnyShouldPrivate * priv;
};

struct _BunnyShouldClass {
	GTypeClass parent_class;
	void (*finalize) (BunnyShould *self);
};

struct _BunnyParamSpecShould {
	GParamSpec parent_instance;
};


static gpointer bunny_vunny_parent_class = NULL;
extern gboolean bunny_expectation_result;
static gpointer bunny_expectation_parent_class = NULL;
gboolean bunny_expectation_result = FALSE;
static gpointer bunny_test_parent_class = NULL;
static gpointer bunny_to_parent_class = NULL;
static gpointer bunny_should_parent_class = NULL;

#define __bunny__ "\n" \
"  bunny vunny test suite v0.0.1\n" \
"\n" \
"          /\\ /\\\n" \
"          \\/_\\/\n" \
"          ('.')\n" \
"         (     )\n" \
"\n" \
"    It's no ordinary rabbit\n" \
"\n"
gpointer bunny_vunny_ref (gpointer instance);
void bunny_vunny_unref (gpointer instance);
GParamSpec* bunny_param_spec_vunny (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void bunny_value_set_vunny (GValue* value, gpointer v_object);
void bunny_value_take_vunny (GValue* value, gpointer v_object);
gpointer bunny_value_get_vunny (const GValue* value);
GType bunny_vunny_get_type (void) G_GNUC_CONST;
gpointer bunny_should_ref (gpointer instance);
void bunny_should_unref (gpointer instance);
GParamSpec* bunny_param_spec_should (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void bunny_value_set_should (GValue* value, gpointer v_object);
void bunny_value_take_should (GValue* value, gpointer v_object);
gpointer bunny_value_get_should (const GValue* value);
GType bunny_should_get_type (void) G_GNUC_CONST;
gpointer bunny_test_ref (gpointer instance);
void bunny_test_unref (gpointer instance);
GParamSpec* bunny_param_spec_test (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void bunny_value_set_test (GValue* value, gpointer v_object);
void bunny_value_take_test (GValue* value, gpointer v_object);
gpointer bunny_value_get_test (const GValue* value);
GType bunny_test_get_type (void) G_GNUC_CONST;
enum  {
	BUNNY_VUNNY_DUMMY_PROPERTY
};
BunnyVunny* bunny_vunny_new (void);
BunnyVunny* bunny_vunny_construct (GType object_type);
BunnyShould* bunny_should_new (void);
BunnyShould* bunny_should_construct (GType object_type);
void bunny_vunny_describe (BunnyVunny* self, const gchar* name);
gpointer bunny_expectation_ref (gpointer instance);
void bunny_expectation_unref (gpointer instance);
GParamSpec* bunny_param_spec_expectation (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void bunny_value_set_expectation (GValue* value, gpointer v_object);
void bunny_value_take_expectation (GValue* value, gpointer v_object);
gpointer bunny_value_get_expectation (const GValue* value);
GType bunny_expectation_get_type (void) G_GNUC_CONST;
BunnyExpectation* bunny_vunny_expect (BunnyVunny* self, GValue* actual);
BunnyExpectation* bunny_expectation_new (GValue* actual);
BunnyExpectation* bunny_expectation_construct (GType object_type, GValue* actual);
void bunny_vunny_test (BunnyVunny* self, const gchar* name, BunnyDelegateTest proc, void* proc_target);
BunnyTest* bunny_test_new (const gchar* name, BunnyDelegateTest proc, void* proc_target);
BunnyTest* bunny_test_construct (GType object_type, const gchar* name, BunnyDelegateTest proc, void* proc_target);
void bunny_vunny_it (BunnyVunny* self, const gchar* name, BunnyDelegateFunc func, void* func_target);
BunnyTest* bunny_test_new_withFunc (const gchar* name, BunnyDelegateFunc func, void* func_target);
BunnyTest* bunny_test_construct_withFunc (GType object_type, const gchar* name, BunnyDelegateFunc func, void* func_target);
void bunny_vunny_run (BunnyVunny* self);
static void bunny_vunny_finalize (BunnyVunny* obj);
gpointer bunny_to_ref (gpointer instance);
void bunny_to_unref (gpointer instance);
GParamSpec* bunny_param_spec_to (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void bunny_value_set_to (GValue* value, gpointer v_object);
void bunny_value_take_to (GValue* value, gpointer v_object);
gpointer bunny_value_get_to (const GValue* value);
GType bunny_to_get_type (void) G_GNUC_CONST;
enum  {
	BUNNY_EXPECTATION_DUMMY_PROPERTY
};
BunnyTo* bunny_to_new (BunnyExpectation* parent);
BunnyTo* bunny_to_construct (GType object_type, BunnyExpectation* parent);
static void bunny_expectation_finalize (BunnyExpectation* obj);
enum  {
	BUNNY_TEST_DUMMY_PROPERTY
};
static void bunny_test_finalize (BunnyTest* obj);
enum  {
	BUNNY_TO_DUMMY_PROPERTY
};
void bunny_to_equal (BunnyTo* self, GValue* expected);
gboolean bunny_should_eq (BunnyShould* self, GValue* actual, GValue* expected);
void bunny_to_gt (BunnyTo* self, GValue* expected);
gboolean bunny_should_gt (BunnyShould* self, GValue* actual, GValue* expected);
void bunny_to_ge (BunnyTo* self, GValue* expected);
gboolean bunny_should_ge (BunnyShould* self, GValue* actual, GValue* expected);
void bunny_to_lt (BunnyTo* self, GValue* expected);
gboolean bunny_should_lt (BunnyShould* self, GValue* actual, GValue* expected);
void bunny_to_le (BunnyTo* self, GValue* expected);
gboolean bunny_should_le (BunnyShould* self, GValue* actual, GValue* expected);
void bunny_to_match (BunnyTo* self, GValue* expected);
gboolean bunny_should_match (BunnyShould* self, const gchar* actual, const gchar* expected);
BunnyTo* bunny_to_get_not (BunnyTo* self);
static void bunny_to_finalize (BunnyTo* obj);
enum  {
	BUNNY_SHOULD_DUMMY_PROPERTY
};
gboolean bunny_should_ne (BunnyShould* self, GValue* actual, GValue* expected);
static void bunny_should_finalize (BunnyShould* obj);


BunnyVunny* bunny_vunny_construct (GType object_type) {
	BunnyVunny* self = NULL;
	BunnyShould* _tmp0_ = NULL;
	self = (BunnyVunny*) g_type_create_instance (object_type);
	_tmp0_ = bunny_should_new ();
	_bunny_should_unref0 (self->should);
	self->should = _tmp0_;
	return self;
}


BunnyVunny* bunny_vunny_new (void) {
	return bunny_vunny_construct (BUNNY_TYPE_VUNNY);
}


void bunny_vunny_describe (BunnyVunny* self, const gchar* name) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->name);
	self->name = _tmp1_;
}


BunnyExpectation* bunny_vunny_expect (BunnyVunny* self, GValue* actual) {
	BunnyExpectation* result = NULL;
	GValue _tmp0_ = {0};
	BunnyExpectation* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (actual != NULL, NULL);
	_tmp0_ = *actual;
	_tmp1_ = bunny_expectation_new (&_tmp0_);
	result = _tmp1_;
	return result;
}


void bunny_vunny_test (BunnyVunny* self, const gchar* name, BunnyDelegateTest proc, void* proc_target) {
	GeeArrayList* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	BunnyDelegateTest _tmp2_ = NULL;
	void* _tmp2__target = NULL;
	BunnyTest* _tmp3_ = NULL;
	BunnyTest* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = self->tests;
	_tmp1_ = name;
	_tmp2_ = proc;
	_tmp2__target = proc_target;
	_tmp3_ = bunny_test_new (_tmp1_, _tmp2_, _tmp2__target);
	_tmp4_ = _tmp3_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp0_, _tmp4_);
	_bunny_test_unref0 (_tmp4_);
}


void bunny_vunny_it (BunnyVunny* self, const gchar* name, BunnyDelegateFunc func, void* func_target) {
	GeeArrayList* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	BunnyDelegateFunc _tmp2_ = NULL;
	void* _tmp2__target = NULL;
	BunnyTest* _tmp3_ = NULL;
	BunnyTest* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = self->tests;
	_tmp1_ = name;
	_tmp2_ = func;
	_tmp2__target = func_target;
	_tmp3_ = bunny_test_new_withFunc (_tmp1_, _tmp2_, _tmp2__target);
	_tmp4_ = _tmp3_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp0_, _tmp4_);
	_bunny_test_unref0 (_tmp4_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void bunny_vunny_run (BunnyVunny* self) {
	const gchar* _tmp0_ = NULL;
	gint _tmp32_ = 0;
	gint _tmp33_ = 0;
	g_return_if_fail (self != NULL);
	self->passed = 0;
	self->failed = 0;
	g_print ("%s\n", __bunny__);
	_tmp0_ = self->name;
	g_print ("\t%s\n---------------------------------\n", _tmp0_);
	{
		GeeArrayList* _test_list = NULL;
		GeeArrayList* _tmp1_ = NULL;
		GeeArrayList* _tmp2_ = NULL;
		gint _test_size = 0;
		GeeArrayList* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		gint _tmp5_ = 0;
		gint _test_index = 0;
		_tmp1_ = self->tests;
		_tmp2_ = _g_object_ref0 (_tmp1_);
		_test_list = _tmp2_;
		_tmp3_ = _test_list;
		_tmp4_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp3_);
		_tmp5_ = _tmp4_;
		_test_size = _tmp5_;
		_test_index = -1;
		while (TRUE) {
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			gint _tmp8_ = 0;
			BunnyTest* test = NULL;
			GeeArrayList* _tmp9_ = NULL;
			gint _tmp10_ = 0;
			gpointer _tmp11_ = NULL;
			BunnyTest* _tmp12_ = NULL;
			gboolean _tmp13_ = FALSE;
			gboolean _tmp25_ = FALSE;
			_tmp6_ = _test_index;
			_test_index = _tmp6_ + 1;
			_tmp7_ = _test_index;
			_tmp8_ = _test_size;
			if (!(_tmp7_ < _tmp8_)) {
				break;
			}
			_tmp9_ = _test_list;
			_tmp10_ = _test_index;
			_tmp11_ = gee_abstract_list_get ((GeeAbstractList*) _tmp9_, _tmp10_);
			test = (BunnyTest*) _tmp11_;
			_tmp12_ = test;
			_tmp13_ = _tmp12_->hasReturn;
			if (_tmp13_) {
				BunnyTest* _tmp14_ = NULL;
				BunnyDelegateFunc _tmp15_ = NULL;
				void* _tmp15__target = NULL;
				gboolean _tmp16_ = FALSE;
				_tmp14_ = test;
				_tmp15_ = _tmp14_->func;
				_tmp15__target = _tmp14_->func_target;
				_tmp16_ = _tmp15_ (_tmp15__target);
				if (_tmp16_) {
					gint _tmp17_ = 0;
					BunnyTest* _tmp18_ = NULL;
					const gchar* _tmp19_ = NULL;
					_tmp17_ = self->passed;
					self->passed = _tmp17_ + 1;
					_tmp18_ = test;
					_tmp19_ = _tmp18_->name;
					g_print ("PASS <=> %s\n", _tmp19_);
				} else {
					gint _tmp20_ = 0;
					BunnyTest* _tmp21_ = NULL;
					const gchar* _tmp22_ = NULL;
					_tmp20_ = self->failed;
					self->failed = _tmp20_ + 1;
					_tmp21_ = test;
					_tmp22_ = _tmp21_->name;
					g_print ("FAIL <=> %s\n", _tmp22_);
				}
			} else {
				BunnyTest* _tmp23_ = NULL;
				BunnyDelegateTest _tmp24_ = NULL;
				void* _tmp24__target = NULL;
				_tmp23_ = test;
				_tmp24_ = _tmp23_->proc;
				_tmp24__target = _tmp23_->proc_target;
				_tmp24_ (_tmp24__target);
			}
			_tmp25_ = bunny_expectation_result;
			if (_tmp25_) {
				gint _tmp26_ = 0;
				BunnyTest* _tmp27_ = NULL;
				const gchar* _tmp28_ = NULL;
				_tmp26_ = self->passed;
				self->passed = _tmp26_ + 1;
				_tmp27_ = test;
				_tmp28_ = _tmp27_->name;
				g_print ("PASS <=> %s\n", _tmp28_);
			} else {
				gint _tmp29_ = 0;
				BunnyTest* _tmp30_ = NULL;
				const gchar* _tmp31_ = NULL;
				_tmp29_ = self->failed;
				self->failed = _tmp29_ + 1;
				_tmp30_ = test;
				_tmp31_ = _tmp30_->name;
				g_print ("FAIL <=> %s\n", _tmp31_);
			}
			_bunny_test_unref0 (test);
		}
		_g_object_unref0 (_test_list);
	}
	g_print ("---------------------------------\n");
	_tmp32_ = self->passed;
	g_print ("    <====> Pass: %d\n", _tmp32_);
	_tmp33_ = self->failed;
	g_print ("    <====> Fail: %d\n\n\033[0m\n", _tmp33_);
}


static void bunny_value_vunny_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void bunny_value_vunny_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		bunny_vunny_unref (value->data[0].v_pointer);
	}
}


static void bunny_value_vunny_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = bunny_vunny_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer bunny_value_vunny_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* bunny_value_vunny_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		BunnyVunny* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = bunny_vunny_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* bunny_value_vunny_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	BunnyVunny** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = bunny_vunny_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* bunny_param_spec_vunny (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	BunnyParamSpecVunny* spec;
	g_return_val_if_fail (g_type_is_a (object_type, BUNNY_TYPE_VUNNY), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer bunny_value_get_vunny (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_VUNNY), NULL);
	return value->data[0].v_pointer;
}


void bunny_value_set_vunny (GValue* value, gpointer v_object) {
	BunnyVunny* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_VUNNY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BUNNY_TYPE_VUNNY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		bunny_vunny_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bunny_vunny_unref (old);
	}
}


void bunny_value_take_vunny (GValue* value, gpointer v_object) {
	BunnyVunny* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_VUNNY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BUNNY_TYPE_VUNNY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bunny_vunny_unref (old);
	}
}


static void bunny_vunny_class_init (BunnyVunnyClass * klass) {
	bunny_vunny_parent_class = g_type_class_peek_parent (klass);
	((BunnyVunnyClass *) klass)->finalize = bunny_vunny_finalize;
}


static void bunny_vunny_instance_init (BunnyVunny * self) {
	gchar* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	self->passed = 0;
	self->failed = 0;
	_tmp0_ = g_strdup ("");
	self->name = _tmp0_;
	_tmp1_ = gee_array_list_new (BUNNY_TYPE_TEST, (GBoxedCopyFunc) bunny_test_ref, bunny_test_unref, NULL, NULL, NULL);
	self->tests = _tmp1_;
	self->ref_count = 1;
}


static void bunny_vunny_finalize (BunnyVunny* obj) {
	BunnyVunny * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BUNNY_TYPE_VUNNY, BunnyVunny);
	g_signal_handlers_destroy (self);
	_g_free0 (self->name);
	_bunny_should_unref0 (self->should);
	_g_object_unref0 (self->tests);
}


/**
     *    Vunny - Vala Unit Testing
     * inspired by Chai
     */
GType bunny_vunny_get_type (void) {
	static volatile gsize bunny_vunny_type_id__volatile = 0;
	if (g_once_init_enter (&bunny_vunny_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { bunny_value_vunny_init, bunny_value_vunny_free_value, bunny_value_vunny_copy_value, bunny_value_vunny_peek_pointer, "p", bunny_value_vunny_collect_value, "p", bunny_value_vunny_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (BunnyVunnyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bunny_vunny_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BunnyVunny), 0, (GInstanceInitFunc) bunny_vunny_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType bunny_vunny_type_id;
		bunny_vunny_type_id = g_type_register_fundamental (g_type_fundamental_next (), "BunnyVunny", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&bunny_vunny_type_id__volatile, bunny_vunny_type_id);
	}
	return bunny_vunny_type_id__volatile;
}


gpointer bunny_vunny_ref (gpointer instance) {
	BunnyVunny* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void bunny_vunny_unref (gpointer instance) {
	BunnyVunny* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		BUNNY_VUNNY_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


BunnyExpectation* bunny_expectation_construct (GType object_type, GValue* actual) {
	BunnyExpectation* self = NULL;
	GValue _tmp0_ = {0};
	GValue _tmp1_ = {0};
	BunnyTo* _tmp2_ = NULL;
	g_return_val_if_fail (actual != NULL, NULL);
	self = (BunnyExpectation*) g_type_create_instance (object_type);
	_tmp0_ = *actual;
	if (G_IS_VALUE (&_tmp0_)) {
		g_value_init (&_tmp1_, G_VALUE_TYPE (&_tmp0_));
		g_value_copy (&_tmp0_, &_tmp1_);
	} else {
		_tmp1_ = _tmp0_;
	}
	G_IS_VALUE (&self->actual) ? (g_value_unset (&self->actual), NULL) : NULL;
	self->actual = _tmp1_;
	_tmp2_ = bunny_to_new (self);
	_bunny_to_unref0 (self->to);
	self->to = _tmp2_;
	return self;
}


BunnyExpectation* bunny_expectation_new (GValue* actual) {
	return bunny_expectation_construct (BUNNY_TYPE_EXPECTATION, actual);
}


static void bunny_value_expectation_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void bunny_value_expectation_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		bunny_expectation_unref (value->data[0].v_pointer);
	}
}


static void bunny_value_expectation_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = bunny_expectation_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer bunny_value_expectation_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* bunny_value_expectation_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		BunnyExpectation* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = bunny_expectation_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* bunny_value_expectation_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	BunnyExpectation** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = bunny_expectation_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* bunny_param_spec_expectation (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	BunnyParamSpecExpectation* spec;
	g_return_val_if_fail (g_type_is_a (object_type, BUNNY_TYPE_EXPECTATION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer bunny_value_get_expectation (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_EXPECTATION), NULL);
	return value->data[0].v_pointer;
}


void bunny_value_set_expectation (GValue* value, gpointer v_object) {
	BunnyExpectation* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_EXPECTATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BUNNY_TYPE_EXPECTATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		bunny_expectation_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bunny_expectation_unref (old);
	}
}


void bunny_value_take_expectation (GValue* value, gpointer v_object) {
	BunnyExpectation* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_EXPECTATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BUNNY_TYPE_EXPECTATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bunny_expectation_unref (old);
	}
}


static void bunny_expectation_class_init (BunnyExpectationClass * klass) {
	bunny_expectation_parent_class = g_type_class_peek_parent (klass);
	((BunnyExpectationClass *) klass)->finalize = bunny_expectation_finalize;
}


static void bunny_expectation_instance_init (BunnyExpectation * self) {
	self->ref_count = 1;
}


static void bunny_expectation_finalize (BunnyExpectation* obj) {
	BunnyExpectation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BUNNY_TYPE_EXPECTATION, BunnyExpectation);
	g_signal_handlers_destroy (self);
	G_IS_VALUE (&self->actual) ? (g_value_unset (&self->actual), NULL) : NULL;
	_bunny_to_unref0 (self->to);
}


/**
     *    Expectation
     */
GType bunny_expectation_get_type (void) {
	static volatile gsize bunny_expectation_type_id__volatile = 0;
	if (g_once_init_enter (&bunny_expectation_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { bunny_value_expectation_init, bunny_value_expectation_free_value, bunny_value_expectation_copy_value, bunny_value_expectation_peek_pointer, "p", bunny_value_expectation_collect_value, "p", bunny_value_expectation_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (BunnyExpectationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bunny_expectation_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BunnyExpectation), 0, (GInstanceInitFunc) bunny_expectation_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType bunny_expectation_type_id;
		bunny_expectation_type_id = g_type_register_fundamental (g_type_fundamental_next (), "BunnyExpectation", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&bunny_expectation_type_id__volatile, bunny_expectation_type_id);
	}
	return bunny_expectation_type_id__volatile;
}


gpointer bunny_expectation_ref (gpointer instance) {
	BunnyExpectation* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void bunny_expectation_unref (gpointer instance) {
	BunnyExpectation* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		BUNNY_EXPECTATION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


BunnyTest* bunny_test_construct (GType object_type, const gchar* name, BunnyDelegateTest proc, void* proc_target) {
	BunnyTest* self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	BunnyDelegateTest _tmp2_ = NULL;
	void* _tmp2__target = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	self = (BunnyTest*) g_type_create_instance (object_type);
	_tmp0_ = name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->name);
	self->name = _tmp1_;
	_tmp2_ = proc;
	_tmp2__target = proc_target;
	self->proc = _tmp2_;
	self->proc_target = _tmp2__target;
	self->result = FALSE;
	self->hasReturn = FALSE;
	return self;
}


BunnyTest* bunny_test_new (const gchar* name, BunnyDelegateTest proc, void* proc_target) {
	return bunny_test_construct (BUNNY_TYPE_TEST, name, proc, proc_target);
}


BunnyTest* bunny_test_construct_withFunc (GType object_type, const gchar* name, BunnyDelegateFunc func, void* func_target) {
	BunnyTest* self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	BunnyDelegateFunc _tmp2_ = NULL;
	void* _tmp2__target = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	self = (BunnyTest*) g_type_create_instance (object_type);
	_tmp0_ = name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->name);
	self->name = _tmp1_;
	_tmp2_ = func;
	_tmp2__target = func_target;
	self->func = _tmp2_;
	self->func_target = _tmp2__target;
	self->result = FALSE;
	self->hasReturn = TRUE;
	return self;
}


BunnyTest* bunny_test_new_withFunc (const gchar* name, BunnyDelegateFunc func, void* func_target) {
	return bunny_test_construct_withFunc (BUNNY_TYPE_TEST, name, func, func_target);
}


static void bunny_value_test_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void bunny_value_test_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		bunny_test_unref (value->data[0].v_pointer);
	}
}


static void bunny_value_test_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = bunny_test_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer bunny_value_test_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* bunny_value_test_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		BunnyTest* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = bunny_test_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* bunny_value_test_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	BunnyTest** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = bunny_test_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* bunny_param_spec_test (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	BunnyParamSpecTest* spec;
	g_return_val_if_fail (g_type_is_a (object_type, BUNNY_TYPE_TEST), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer bunny_value_get_test (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_TEST), NULL);
	return value->data[0].v_pointer;
}


void bunny_value_set_test (GValue* value, gpointer v_object) {
	BunnyTest* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_TEST));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BUNNY_TYPE_TEST));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		bunny_test_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bunny_test_unref (old);
	}
}


void bunny_value_take_test (GValue* value, gpointer v_object) {
	BunnyTest* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_TEST));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BUNNY_TYPE_TEST));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bunny_test_unref (old);
	}
}


static void bunny_test_class_init (BunnyTestClass * klass) {
	bunny_test_parent_class = g_type_class_peek_parent (klass);
	((BunnyTestClass *) klass)->finalize = bunny_test_finalize;
}


static void bunny_test_instance_init (BunnyTest * self) {
	self->ref_count = 1;
}


static void bunny_test_finalize (BunnyTest* obj) {
	BunnyTest * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BUNNY_TYPE_TEST, BunnyTest);
	g_signal_handlers_destroy (self);
	_g_free0 (self->name);
}


/**
     *    Test
     *    name & func of each test
     */
GType bunny_test_get_type (void) {
	static volatile gsize bunny_test_type_id__volatile = 0;
	if (g_once_init_enter (&bunny_test_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { bunny_value_test_init, bunny_value_test_free_value, bunny_value_test_copy_value, bunny_value_test_peek_pointer, "p", bunny_value_test_collect_value, "p", bunny_value_test_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (BunnyTestClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bunny_test_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BunnyTest), 0, (GInstanceInitFunc) bunny_test_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType bunny_test_type_id;
		bunny_test_type_id = g_type_register_fundamental (g_type_fundamental_next (), "BunnyTest", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&bunny_test_type_id__volatile, bunny_test_type_id);
	}
	return bunny_test_type_id__volatile;
}


gpointer bunny_test_ref (gpointer instance) {
	BunnyTest* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void bunny_test_unref (gpointer instance) {
	BunnyTest* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		BUNNY_TEST_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static gpointer _bunny_expectation_ref0 (gpointer self) {
	return self ? bunny_expectation_ref (self) : NULL;
}


BunnyTo* bunny_to_construct (GType object_type, BunnyExpectation* parent) {
	BunnyTo* self = NULL;
	BunnyExpectation* _tmp0_ = NULL;
	BunnyExpectation* _tmp1_ = NULL;
	BunnyShould* _tmp2_ = NULL;
	g_return_val_if_fail (parent != NULL, NULL);
	self = (BunnyTo*) g_type_create_instance (object_type);
	_tmp0_ = parent;
	_tmp1_ = _bunny_expectation_ref0 (_tmp0_);
	_bunny_expectation_unref0 (self->parent);
	self->parent = _tmp1_;
	_tmp2_ = bunny_should_new ();
	_bunny_should_unref0 (self->should);
	self->should = _tmp2_;
	return self;
}


BunnyTo* bunny_to_new (BunnyExpectation* parent) {
	return bunny_to_construct (BUNNY_TYPE_TO, parent);
}


void bunny_to_equal (BunnyTo* self, GValue* expected) {
	gboolean test = FALSE;
	BunnyShould* _tmp0_ = NULL;
	BunnyExpectation* _tmp1_ = NULL;
	GValue _tmp2_ = {0};
	GValue _tmp3_ = {0};
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (expected != NULL);
	_tmp0_ = self->should;
	_tmp1_ = self->parent;
	_tmp2_ = _tmp1_->actual;
	_tmp3_ = *expected;
	_tmp4_ = bunny_should_eq (_tmp0_, &_tmp2_, &_tmp3_);
	test = _tmp4_;
	_tmp6_ = self->invert;
	if (_tmp6_) {
		gboolean _tmp7_ = FALSE;
		_tmp7_ = test;
		_tmp5_ = !_tmp7_;
	} else {
		gboolean _tmp8_ = FALSE;
		_tmp8_ = test;
		_tmp5_ = _tmp8_;
	}
	bunny_expectation_result = _tmp5_;
}


void bunny_to_gt (BunnyTo* self, GValue* expected) {
	gboolean test = FALSE;
	BunnyShould* _tmp0_ = NULL;
	BunnyExpectation* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	GValue _tmp3_ = {0};
	const gchar* _tmp4_ = NULL;
	GValue _tmp5_ = {0};
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (expected != NULL);
	_tmp0_ = self->should;
	_tmp1_ = self->parent;
	_tmp2_ = g_value_get_string (&_tmp1_->actual);
	g_value_init (&_tmp3_, G_TYPE_STRING);
	g_value_set_string (&_tmp3_, _tmp2_);
	_tmp4_ = g_value_get_string (expected);
	g_value_init (&_tmp5_, G_TYPE_STRING);
	g_value_set_string (&_tmp5_, _tmp4_);
	_tmp6_ = bunny_should_gt (_tmp0_, &_tmp3_, &_tmp5_);
	_tmp7_ = _tmp6_;
	G_IS_VALUE (&_tmp5_) ? (g_value_unset (&_tmp5_), NULL) : NULL;
	G_IS_VALUE (&_tmp3_) ? (g_value_unset (&_tmp3_), NULL) : NULL;
	test = _tmp7_;
	_tmp9_ = self->invert;
	if (_tmp9_) {
		gboolean _tmp10_ = FALSE;
		_tmp10_ = test;
		_tmp8_ = !_tmp10_;
	} else {
		gboolean _tmp11_ = FALSE;
		_tmp11_ = test;
		_tmp8_ = _tmp11_;
	}
	bunny_expectation_result = _tmp8_;
}


void bunny_to_ge (BunnyTo* self, GValue* expected) {
	gboolean test = FALSE;
	BunnyShould* _tmp0_ = NULL;
	BunnyExpectation* _tmp1_ = NULL;
	GValue _tmp2_ = {0};
	GValue _tmp3_ = {0};
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (expected != NULL);
	_tmp0_ = self->should;
	_tmp1_ = self->parent;
	_tmp2_ = _tmp1_->actual;
	_tmp3_ = *expected;
	_tmp4_ = bunny_should_ge (_tmp0_, &_tmp2_, &_tmp3_);
	test = _tmp4_;
	_tmp6_ = self->invert;
	if (_tmp6_) {
		gboolean _tmp7_ = FALSE;
		_tmp7_ = test;
		_tmp5_ = !_tmp7_;
	} else {
		gboolean _tmp8_ = FALSE;
		_tmp8_ = test;
		_tmp5_ = _tmp8_;
	}
	bunny_expectation_result = _tmp5_;
}


void bunny_to_lt (BunnyTo* self, GValue* expected) {
	gboolean test = FALSE;
	BunnyShould* _tmp0_ = NULL;
	BunnyExpectation* _tmp1_ = NULL;
	GValue _tmp2_ = {0};
	GValue _tmp3_ = {0};
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (expected != NULL);
	_tmp0_ = self->should;
	_tmp1_ = self->parent;
	_tmp2_ = _tmp1_->actual;
	_tmp3_ = *expected;
	_tmp4_ = bunny_should_lt (_tmp0_, &_tmp2_, &_tmp3_);
	test = _tmp4_;
	_tmp6_ = self->invert;
	if (_tmp6_) {
		gboolean _tmp7_ = FALSE;
		_tmp7_ = test;
		_tmp5_ = !_tmp7_;
	} else {
		gboolean _tmp8_ = FALSE;
		_tmp8_ = test;
		_tmp5_ = _tmp8_;
	}
	bunny_expectation_result = _tmp5_;
}


void bunny_to_le (BunnyTo* self, GValue* expected) {
	gboolean test = FALSE;
	BunnyShould* _tmp0_ = NULL;
	BunnyExpectation* _tmp1_ = NULL;
	GValue _tmp2_ = {0};
	GValue _tmp3_ = {0};
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (expected != NULL);
	_tmp0_ = self->should;
	_tmp1_ = self->parent;
	_tmp2_ = _tmp1_->actual;
	_tmp3_ = *expected;
	_tmp4_ = bunny_should_le (_tmp0_, &_tmp2_, &_tmp3_);
	test = _tmp4_;
	_tmp6_ = self->invert;
	if (_tmp6_) {
		gboolean _tmp7_ = FALSE;
		_tmp7_ = test;
		_tmp5_ = !_tmp7_;
	} else {
		gboolean _tmp8_ = FALSE;
		_tmp8_ = test;
		_tmp5_ = _tmp8_;
	}
	bunny_expectation_result = _tmp5_;
}


void bunny_to_match (BunnyTo* self, GValue* expected) {
	gboolean test = FALSE;
	BunnyShould* _tmp0_ = NULL;
	BunnyExpectation* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (expected != NULL);
	_tmp0_ = self->should;
	_tmp1_ = self->parent;
	_tmp2_ = g_value_get_string (&_tmp1_->actual);
	_tmp3_ = g_value_get_string (expected);
	_tmp4_ = bunny_should_match (_tmp0_, _tmp2_, _tmp3_);
	test = _tmp4_;
	_tmp6_ = self->invert;
	if (_tmp6_) {
		gboolean _tmp7_ = FALSE;
		_tmp7_ = test;
		_tmp5_ = !_tmp7_;
	} else {
		gboolean _tmp8_ = FALSE;
		_tmp8_ = test;
		_tmp5_ = _tmp8_;
	}
	bunny_expectation_result = _tmp5_;
}


BunnyTo* bunny_to_get_not (BunnyTo* self) {
	BunnyTo* result;
	g_return_val_if_fail (self != NULL, NULL);
	self->invert = TRUE;
	result = self;
	return result;
}


static void bunny_value_to_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void bunny_value_to_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		bunny_to_unref (value->data[0].v_pointer);
	}
}


static void bunny_value_to_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = bunny_to_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer bunny_value_to_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* bunny_value_to_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		BunnyTo* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = bunny_to_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* bunny_value_to_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	BunnyTo** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = bunny_to_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* bunny_param_spec_to (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	BunnyParamSpecTo* spec;
	g_return_val_if_fail (g_type_is_a (object_type, BUNNY_TYPE_TO), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer bunny_value_get_to (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_TO), NULL);
	return value->data[0].v_pointer;
}


void bunny_value_set_to (GValue* value, gpointer v_object) {
	BunnyTo* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_TO));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BUNNY_TYPE_TO));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		bunny_to_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bunny_to_unref (old);
	}
}


void bunny_value_take_to (GValue* value, gpointer v_object) {
	BunnyTo* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_TO));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BUNNY_TYPE_TO));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bunny_to_unref (old);
	}
}


static void bunny_to_class_init (BunnyToClass * klass) {
	bunny_to_parent_class = g_type_class_peek_parent (klass);
	((BunnyToClass *) klass)->finalize = bunny_to_finalize;
}


static void bunny_to_instance_init (BunnyTo * self) {
	self->invert = FALSE;
	self->ref_count = 1;
}


static void bunny_to_finalize (BunnyTo* obj) {
	BunnyTo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BUNNY_TYPE_TO, BunnyTo);
	g_signal_handlers_destroy (self);
	_bunny_expectation_unref0 (self->parent);
	_bunny_should_unref0 (self->should);
}


/**
     *    To
     */
GType bunny_to_get_type (void) {
	static volatile gsize bunny_to_type_id__volatile = 0;
	if (g_once_init_enter (&bunny_to_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { bunny_value_to_init, bunny_value_to_free_value, bunny_value_to_copy_value, bunny_value_to_peek_pointer, "p", bunny_value_to_collect_value, "p", bunny_value_to_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (BunnyToClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bunny_to_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BunnyTo), 0, (GInstanceInitFunc) bunny_to_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType bunny_to_type_id;
		bunny_to_type_id = g_type_register_fundamental (g_type_fundamental_next (), "BunnyTo", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&bunny_to_type_id__volatile, bunny_to_type_id);
	}
	return bunny_to_type_id__volatile;
}


gpointer bunny_to_ref (gpointer instance) {
	BunnyTo* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void bunny_to_unref (gpointer instance) {
	BunnyTo* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		BUNNY_TO_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


gboolean bunny_should_match (BunnyShould* self, const gchar* actual, const gchar* expected) {
	gboolean result = FALSE;
	gboolean _result_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (actual != NULL, FALSE);
	g_return_val_if_fail (expected != NULL, FALSE);
	_result_ = FALSE;
	{
		GRegex* r = NULL;
		const gchar* _tmp0_ = NULL;
		GRegex* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		_tmp0_ = expected;
		_tmp1_ = g_regex_new (_tmp0_, 0, 0, &_inner_error_);
		r = _tmp1_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch5_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		_tmp2_ = actual;
		_tmp3_ = g_regex_match (r, _tmp2_, 0, NULL);
		_result_ = _tmp3_;
		_g_regex_unref0 (r);
	}
	goto __finally5;
	__catch5_g_regex_error:
	{
		GError* e = NULL;
		FILE* _tmp4_ = NULL;
		GError* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = stdout;
		_tmp5_ = e;
		_tmp6_ = _tmp5_->message;
		fprintf (_tmp4_, "Error %s\n", _tmp6_);
		_g_error_free0 (e);
	}
	__finally5:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = _result_;
	return result;
}


/**
         *    eq - check equality
         *
         * @param expected pattern
         * @param actual value
         * @returns true or false
         */
gboolean bunny_should_eq (BunnyShould* self, GValue* actual, GValue* expected) {
	gboolean result = FALSE;
	gboolean test = FALSE;
	GType t = 0UL;
	GType _tmp0_ = 0UL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (actual != NULL, FALSE);
	g_return_val_if_fail (expected != NULL, FALSE);
	test = FALSE;
	_tmp0_ = G_VALUE_TYPE (expected);
	t = _tmp0_;
	_tmp1_ = G_VALUE_TYPE_NAME (expected);
	_tmp2_ = G_VALUE_TYPE_NAME (actual);
	if (g_strcmp0 (_tmp1_, _tmp2_) == 0) {
		GType _tmp3_ = 0UL;
		gboolean _tmp4_ = FALSE;
		_tmp3_ = t;
		_tmp4_ = g_type_is_a (_tmp3_, G_TYPE_STRING);
		if (_tmp4_) {
			const gchar* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			_tmp5_ = g_value_get_string (expected);
			_tmp6_ = g_value_get_string (actual);
			test = g_strcmp0 (_tmp5_, _tmp6_) == 0;
		} else {
			GType _tmp7_ = 0UL;
			gboolean _tmp8_ = FALSE;
			_tmp7_ = t;
			_tmp8_ = g_type_is_a (_tmp7_, G_TYPE_BOOLEAN);
			if (_tmp8_) {
				gboolean _tmp9_ = FALSE;
				gboolean _tmp10_ = FALSE;
				_tmp9_ = g_value_get_boolean (expected);
				_tmp10_ = g_value_get_boolean (actual);
				test = _tmp9_ == _tmp10_;
			} else {
				GType _tmp11_ = 0UL;
				gboolean _tmp12_ = FALSE;
				_tmp11_ = t;
				_tmp12_ = g_type_is_a (_tmp11_, G_TYPE_INT);
				if (_tmp12_) {
					gint _tmp13_ = 0;
					gint _tmp14_ = 0;
					_tmp13_ = g_value_get_int (expected);
					_tmp14_ = g_value_get_int (actual);
					test = _tmp13_ == _tmp14_;
				} else {
					GType _tmp15_ = 0UL;
					gboolean _tmp16_ = FALSE;
					_tmp15_ = t;
					_tmp16_ = g_type_is_a (_tmp15_, G_TYPE_LONG);
					if (_tmp16_) {
						glong _tmp17_ = 0L;
						glong _tmp18_ = 0L;
						_tmp17_ = g_value_get_long (expected);
						_tmp18_ = g_value_get_long (actual);
						test = _tmp17_ == _tmp18_;
					} else {
						GType _tmp19_ = 0UL;
						gboolean _tmp20_ = FALSE;
						_tmp19_ = t;
						_tmp20_ = g_type_is_a (_tmp19_, G_TYPE_CHAR);
						if (_tmp20_) {
							gchar _tmp21_ = '\0';
							gchar _tmp22_ = '\0';
							_tmp21_ = g_value_get_char (expected);
							_tmp22_ = g_value_get_char (actual);
							test = _tmp21_ == _tmp22_;
						} else {
							GType _tmp23_ = 0UL;
							gboolean _tmp24_ = FALSE;
							_tmp23_ = t;
							_tmp24_ = g_type_is_a (_tmp23_, G_TYPE_DOUBLE);
							if (_tmp24_) {
								gdouble _tmp25_ = 0.0;
								gdouble _tmp26_ = 0.0;
								_tmp25_ = g_value_get_double (expected);
								_tmp26_ = g_value_get_double (actual);
								test = _tmp25_ == _tmp26_;
							} else {
								GType _tmp27_ = 0UL;
								gboolean _tmp28_ = FALSE;
								_tmp27_ = t;
								_tmp28_ = g_type_is_a (_tmp27_, G_TYPE_FLOAT);
								if (_tmp28_) {
									gfloat _tmp29_ = 0.0F;
									gfloat _tmp30_ = 0.0F;
									_tmp29_ = g_value_get_float (expected);
									_tmp30_ = g_value_get_float (actual);
									test = _tmp29_ == _tmp30_;
								}
							}
						}
					}
				}
			}
		}
	}
	result = test;
	return result;
}


/**
         *    ne - check inequality
         *
         * @param expected pattern
         * @param actual value
         * @returns true or false
         */
gboolean bunny_should_ne (BunnyShould* self, GValue* actual, GValue* expected) {
	gboolean result = FALSE;
	gboolean test = FALSE;
	GType t = 0UL;
	GType _tmp0_ = 0UL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (actual != NULL, FALSE);
	g_return_val_if_fail (expected != NULL, FALSE);
	test = FALSE;
	_tmp0_ = G_VALUE_TYPE (expected);
	t = _tmp0_;
	_tmp1_ = G_VALUE_TYPE_NAME (expected);
	_tmp2_ = G_VALUE_TYPE_NAME (actual);
	if (g_strcmp0 (_tmp1_, _tmp2_) == 0) {
		GType _tmp3_ = 0UL;
		gboolean _tmp4_ = FALSE;
		_tmp3_ = t;
		_tmp4_ = g_type_is_a (_tmp3_, G_TYPE_STRING);
		if (_tmp4_) {
			const gchar* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			_tmp5_ = g_value_get_string (expected);
			_tmp6_ = g_value_get_string (actual);
			test = g_strcmp0 (_tmp5_, _tmp6_) != 0;
		} else {
			GType _tmp7_ = 0UL;
			gboolean _tmp8_ = FALSE;
			_tmp7_ = t;
			_tmp8_ = g_type_is_a (_tmp7_, G_TYPE_BOOLEAN);
			if (_tmp8_) {
				gboolean _tmp9_ = FALSE;
				gboolean _tmp10_ = FALSE;
				_tmp9_ = g_value_get_boolean (expected);
				_tmp10_ = g_value_get_boolean (actual);
				test = _tmp9_ != _tmp10_;
			} else {
				GType _tmp11_ = 0UL;
				gboolean _tmp12_ = FALSE;
				_tmp11_ = t;
				_tmp12_ = g_type_is_a (_tmp11_, G_TYPE_INT);
				if (_tmp12_) {
					gint _tmp13_ = 0;
					gint _tmp14_ = 0;
					_tmp13_ = g_value_get_int (expected);
					_tmp14_ = g_value_get_int (actual);
					test = _tmp13_ != _tmp14_;
				} else {
					GType _tmp15_ = 0UL;
					gboolean _tmp16_ = FALSE;
					_tmp15_ = t;
					_tmp16_ = g_type_is_a (_tmp15_, G_TYPE_LONG);
					if (_tmp16_) {
						glong _tmp17_ = 0L;
						glong _tmp18_ = 0L;
						_tmp17_ = g_value_get_long (expected);
						_tmp18_ = g_value_get_long (actual);
						test = _tmp17_ != _tmp18_;
					} else {
						GType _tmp19_ = 0UL;
						gboolean _tmp20_ = FALSE;
						_tmp19_ = t;
						_tmp20_ = g_type_is_a (_tmp19_, G_TYPE_CHAR);
						if (_tmp20_) {
							gchar _tmp21_ = '\0';
							gchar _tmp22_ = '\0';
							_tmp21_ = g_value_get_char (expected);
							_tmp22_ = g_value_get_char (actual);
							test = _tmp21_ != _tmp22_;
						} else {
							GType _tmp23_ = 0UL;
							gboolean _tmp24_ = FALSE;
							_tmp23_ = t;
							_tmp24_ = g_type_is_a (_tmp23_, G_TYPE_DOUBLE);
							if (_tmp24_) {
								gdouble _tmp25_ = 0.0;
								gdouble _tmp26_ = 0.0;
								_tmp25_ = g_value_get_double (expected);
								_tmp26_ = g_value_get_double (actual);
								test = _tmp25_ != _tmp26_;
							} else {
								GType _tmp27_ = 0UL;
								gboolean _tmp28_ = FALSE;
								_tmp27_ = t;
								_tmp28_ = g_type_is_a (_tmp27_, G_TYPE_FLOAT);
								if (_tmp28_) {
									gfloat _tmp29_ = 0.0F;
									gfloat _tmp30_ = 0.0F;
									_tmp29_ = g_value_get_float (expected);
									_tmp30_ = g_value_get_float (actual);
									test = _tmp29_ != _tmp30_;
								}
							}
						}
					}
				}
			}
		}
	}
	result = test;
	return result;
}


/**
         *    le - check less than or equal
         *
         * @param expected pattern
         * @param actual value
         * @returns true or false
         */
gboolean bunny_should_le (BunnyShould* self, GValue* actual, GValue* expected) {
	gboolean result = FALSE;
	gboolean test = FALSE;
	GType t = 0UL;
	GType _tmp0_ = 0UL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (actual != NULL, FALSE);
	g_return_val_if_fail (expected != NULL, FALSE);
	test = FALSE;
	_tmp0_ = G_VALUE_TYPE (expected);
	t = _tmp0_;
	_tmp1_ = G_VALUE_TYPE_NAME (expected);
	_tmp2_ = G_VALUE_TYPE_NAME (actual);
	if (g_strcmp0 (_tmp1_, _tmp2_) == 0) {
		GType _tmp3_ = 0UL;
		gboolean _tmp4_ = FALSE;
		_tmp3_ = t;
		_tmp4_ = g_type_is_a (_tmp3_, G_TYPE_STRING);
		if (_tmp4_) {
			const gchar* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			_tmp5_ = g_value_get_string (expected);
			_tmp6_ = g_value_get_string (actual);
			test = g_strcmp0 (_tmp5_, _tmp6_) <= 0;
		} else {
			GType _tmp7_ = 0UL;
			gboolean _tmp8_ = FALSE;
			_tmp7_ = t;
			_tmp8_ = g_type_is_a (_tmp7_, G_TYPE_INT);
			if (_tmp8_) {
				gint _tmp9_ = 0;
				gint _tmp10_ = 0;
				_tmp9_ = g_value_get_int (expected);
				_tmp10_ = g_value_get_int (actual);
				test = _tmp9_ <= _tmp10_;
			} else {
				GType _tmp11_ = 0UL;
				gboolean _tmp12_ = FALSE;
				_tmp11_ = t;
				_tmp12_ = g_type_is_a (_tmp11_, G_TYPE_LONG);
				if (_tmp12_) {
					glong _tmp13_ = 0L;
					glong _tmp14_ = 0L;
					_tmp13_ = g_value_get_long (expected);
					_tmp14_ = g_value_get_long (actual);
					test = _tmp13_ <= _tmp14_;
				} else {
					GType _tmp15_ = 0UL;
					gboolean _tmp16_ = FALSE;
					_tmp15_ = t;
					_tmp16_ = g_type_is_a (_tmp15_, G_TYPE_CHAR);
					if (_tmp16_) {
						gchar _tmp17_ = '\0';
						gchar _tmp18_ = '\0';
						_tmp17_ = g_value_get_char (expected);
						_tmp18_ = g_value_get_char (actual);
						test = _tmp17_ <= _tmp18_;
					} else {
						GType _tmp19_ = 0UL;
						gboolean _tmp20_ = FALSE;
						_tmp19_ = t;
						_tmp20_ = g_type_is_a (_tmp19_, G_TYPE_DOUBLE);
						if (_tmp20_) {
							gdouble _tmp21_ = 0.0;
							gdouble _tmp22_ = 0.0;
							_tmp21_ = g_value_get_double (expected);
							_tmp22_ = g_value_get_double (actual);
							test = _tmp21_ <= _tmp22_;
						} else {
							GType _tmp23_ = 0UL;
							gboolean _tmp24_ = FALSE;
							_tmp23_ = t;
							_tmp24_ = g_type_is_a (_tmp23_, G_TYPE_FLOAT);
							if (_tmp24_) {
								gfloat _tmp25_ = 0.0F;
								gfloat _tmp26_ = 0.0F;
								_tmp25_ = g_value_get_float (expected);
								_tmp26_ = g_value_get_float (actual);
								test = _tmp25_ <= _tmp26_;
							}
						}
					}
				}
			}
		}
	}
	result = test;
	return result;
}


/**
         *    lt - check less than
         *
         * @param expected pattern
         * @param actual value
         * @returns true or false
         */
gboolean bunny_should_lt (BunnyShould* self, GValue* actual, GValue* expected) {
	gboolean result = FALSE;
	gboolean test = FALSE;
	GType t = 0UL;
	GType _tmp0_ = 0UL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (actual != NULL, FALSE);
	g_return_val_if_fail (expected != NULL, FALSE);
	test = FALSE;
	_tmp0_ = G_VALUE_TYPE (expected);
	t = _tmp0_;
	_tmp1_ = G_VALUE_TYPE_NAME (expected);
	_tmp2_ = G_VALUE_TYPE_NAME (actual);
	if (g_strcmp0 (_tmp1_, _tmp2_) == 0) {
		GType _tmp3_ = 0UL;
		gboolean _tmp4_ = FALSE;
		_tmp3_ = t;
		_tmp4_ = g_type_is_a (_tmp3_, G_TYPE_STRING);
		if (_tmp4_) {
			const gchar* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			_tmp5_ = g_value_get_string (expected);
			_tmp6_ = g_value_get_string (actual);
			test = g_strcmp0 (_tmp5_, _tmp6_) < 0;
		} else {
			GType _tmp7_ = 0UL;
			gboolean _tmp8_ = FALSE;
			_tmp7_ = t;
			_tmp8_ = g_type_is_a (_tmp7_, G_TYPE_INT);
			if (_tmp8_) {
				gint _tmp9_ = 0;
				gint _tmp10_ = 0;
				_tmp9_ = g_value_get_int (expected);
				_tmp10_ = g_value_get_int (actual);
				test = _tmp9_ < _tmp10_;
			} else {
				GType _tmp11_ = 0UL;
				gboolean _tmp12_ = FALSE;
				_tmp11_ = t;
				_tmp12_ = g_type_is_a (_tmp11_, G_TYPE_LONG);
				if (_tmp12_) {
					glong _tmp13_ = 0L;
					glong _tmp14_ = 0L;
					_tmp13_ = g_value_get_long (expected);
					_tmp14_ = g_value_get_long (actual);
					test = _tmp13_ < _tmp14_;
				} else {
					GType _tmp15_ = 0UL;
					gboolean _tmp16_ = FALSE;
					_tmp15_ = t;
					_tmp16_ = g_type_is_a (_tmp15_, G_TYPE_CHAR);
					if (_tmp16_) {
						gchar _tmp17_ = '\0';
						gchar _tmp18_ = '\0';
						_tmp17_ = g_value_get_char (expected);
						_tmp18_ = g_value_get_char (actual);
						test = _tmp17_ < _tmp18_;
					} else {
						GType _tmp19_ = 0UL;
						gboolean _tmp20_ = FALSE;
						_tmp19_ = t;
						_tmp20_ = g_type_is_a (_tmp19_, G_TYPE_DOUBLE);
						if (_tmp20_) {
							gdouble _tmp21_ = 0.0;
							gdouble _tmp22_ = 0.0;
							_tmp21_ = g_value_get_double (expected);
							_tmp22_ = g_value_get_double (actual);
							test = _tmp21_ < _tmp22_;
						} else {
							GType _tmp23_ = 0UL;
							gboolean _tmp24_ = FALSE;
							_tmp23_ = t;
							_tmp24_ = g_type_is_a (_tmp23_, G_TYPE_FLOAT);
							if (_tmp24_) {
								gfloat _tmp25_ = 0.0F;
								gfloat _tmp26_ = 0.0F;
								_tmp25_ = g_value_get_float (expected);
								_tmp26_ = g_value_get_float (actual);
								test = _tmp25_ < _tmp26_;
							}
						}
					}
				}
			}
		}
	}
	result = test;
	return result;
}


/**
         *    gt - check greater than
         *
         * @param expected pattern
         * @param actual value
         * @returns true or false
         */
gboolean bunny_should_gt (BunnyShould* self, GValue* actual, GValue* expected) {
	gboolean result = FALSE;
	gboolean test = FALSE;
	GType t = 0UL;
	GType _tmp0_ = 0UL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (actual != NULL, FALSE);
	g_return_val_if_fail (expected != NULL, FALSE);
	test = FALSE;
	_tmp0_ = G_VALUE_TYPE (expected);
	t = _tmp0_;
	_tmp1_ = G_VALUE_TYPE_NAME (expected);
	_tmp2_ = G_VALUE_TYPE_NAME (actual);
	if (g_strcmp0 (_tmp1_, _tmp2_) == 0) {
		GType _tmp3_ = 0UL;
		gboolean _tmp4_ = FALSE;
		_tmp3_ = t;
		_tmp4_ = g_type_is_a (_tmp3_, G_TYPE_STRING);
		if (_tmp4_) {
			const gchar* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			_tmp5_ = g_value_get_string (expected);
			_tmp6_ = g_value_get_string (actual);
			test = g_strcmp0 (_tmp5_, _tmp6_) > 0;
		} else {
			GType _tmp7_ = 0UL;
			gboolean _tmp8_ = FALSE;
			_tmp7_ = t;
			_tmp8_ = g_type_is_a (_tmp7_, G_TYPE_INT);
			if (_tmp8_) {
				gint _tmp9_ = 0;
				gint _tmp10_ = 0;
				_tmp9_ = g_value_get_int (expected);
				_tmp10_ = g_value_get_int (actual);
				test = _tmp9_ > _tmp10_;
			} else {
				GType _tmp11_ = 0UL;
				gboolean _tmp12_ = FALSE;
				_tmp11_ = t;
				_tmp12_ = g_type_is_a (_tmp11_, G_TYPE_LONG);
				if (_tmp12_) {
					glong _tmp13_ = 0L;
					glong _tmp14_ = 0L;
					_tmp13_ = g_value_get_long (expected);
					_tmp14_ = g_value_get_long (actual);
					test = _tmp13_ > _tmp14_;
				} else {
					GType _tmp15_ = 0UL;
					gboolean _tmp16_ = FALSE;
					_tmp15_ = t;
					_tmp16_ = g_type_is_a (_tmp15_, G_TYPE_CHAR);
					if (_tmp16_) {
						gchar _tmp17_ = '\0';
						gchar _tmp18_ = '\0';
						_tmp17_ = g_value_get_char (expected);
						_tmp18_ = g_value_get_char (actual);
						test = _tmp17_ > _tmp18_;
					} else {
						GType _tmp19_ = 0UL;
						gboolean _tmp20_ = FALSE;
						_tmp19_ = t;
						_tmp20_ = g_type_is_a (_tmp19_, G_TYPE_DOUBLE);
						if (_tmp20_) {
							gdouble _tmp21_ = 0.0;
							gdouble _tmp22_ = 0.0;
							_tmp21_ = g_value_get_double (expected);
							_tmp22_ = g_value_get_double (actual);
							test = _tmp21_ > _tmp22_;
						} else {
							GType _tmp23_ = 0UL;
							gboolean _tmp24_ = FALSE;
							_tmp23_ = t;
							_tmp24_ = g_type_is_a (_tmp23_, G_TYPE_FLOAT);
							if (_tmp24_) {
								gfloat _tmp25_ = 0.0F;
								gfloat _tmp26_ = 0.0F;
								_tmp25_ = g_value_get_float (expected);
								_tmp26_ = g_value_get_float (actual);
								test = _tmp25_ > _tmp26_;
							}
						}
					}
				}
			}
		}
	}
	result = test;
	return result;
}


/**
         *    ge - check greater than or equal
         *
         * @param expected pattern
         * @param actual value
         * @returns true or false
         */
gboolean bunny_should_ge (BunnyShould* self, GValue* actual, GValue* expected) {
	gboolean result = FALSE;
	gboolean test = FALSE;
	GType t = 0UL;
	GType _tmp0_ = 0UL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (actual != NULL, FALSE);
	g_return_val_if_fail (expected != NULL, FALSE);
	test = FALSE;
	_tmp0_ = G_VALUE_TYPE (expected);
	t = _tmp0_;
	_tmp1_ = G_VALUE_TYPE_NAME (expected);
	_tmp2_ = G_VALUE_TYPE_NAME (actual);
	if (g_strcmp0 (_tmp1_, _tmp2_) == 0) {
		GType _tmp3_ = 0UL;
		gboolean _tmp4_ = FALSE;
		_tmp3_ = t;
		_tmp4_ = g_type_is_a (_tmp3_, G_TYPE_STRING);
		if (_tmp4_) {
			const gchar* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			_tmp5_ = g_value_get_string (expected);
			_tmp6_ = g_value_get_string (actual);
			test = g_strcmp0 (_tmp5_, _tmp6_) >= 0;
		} else {
			GType _tmp7_ = 0UL;
			gboolean _tmp8_ = FALSE;
			_tmp7_ = t;
			_tmp8_ = g_type_is_a (_tmp7_, G_TYPE_INT);
			if (_tmp8_) {
				gint _tmp9_ = 0;
				gint _tmp10_ = 0;
				_tmp9_ = g_value_get_int (expected);
				_tmp10_ = g_value_get_int (actual);
				test = _tmp9_ >= _tmp10_;
			} else {
				GType _tmp11_ = 0UL;
				gboolean _tmp12_ = FALSE;
				_tmp11_ = t;
				_tmp12_ = g_type_is_a (_tmp11_, G_TYPE_LONG);
				if (_tmp12_) {
					glong _tmp13_ = 0L;
					glong _tmp14_ = 0L;
					_tmp13_ = g_value_get_long (expected);
					_tmp14_ = g_value_get_long (actual);
					test = _tmp13_ >= _tmp14_;
				} else {
					GType _tmp15_ = 0UL;
					gboolean _tmp16_ = FALSE;
					_tmp15_ = t;
					_tmp16_ = g_type_is_a (_tmp15_, G_TYPE_CHAR);
					if (_tmp16_) {
						gchar _tmp17_ = '\0';
						gchar _tmp18_ = '\0';
						_tmp17_ = g_value_get_char (expected);
						_tmp18_ = g_value_get_char (actual);
						test = _tmp17_ >= _tmp18_;
					} else {
						GType _tmp19_ = 0UL;
						gboolean _tmp20_ = FALSE;
						_tmp19_ = t;
						_tmp20_ = g_type_is_a (_tmp19_, G_TYPE_DOUBLE);
						if (_tmp20_) {
							gdouble _tmp21_ = 0.0;
							gdouble _tmp22_ = 0.0;
							_tmp21_ = g_value_get_double (expected);
							_tmp22_ = g_value_get_double (actual);
							test = _tmp21_ >= _tmp22_;
						} else {
							GType _tmp23_ = 0UL;
							gboolean _tmp24_ = FALSE;
							_tmp23_ = t;
							_tmp24_ = g_type_is_a (_tmp23_, G_TYPE_FLOAT);
							if (_tmp24_) {
								gfloat _tmp25_ = 0.0F;
								gfloat _tmp26_ = 0.0F;
								_tmp25_ = g_value_get_float (expected);
								_tmp26_ = g_value_get_float (actual);
								test = _tmp25_ >= _tmp26_;
							}
						}
					}
				}
			}
		}
	}
	result = test;
	return result;
}


BunnyShould* bunny_should_construct (GType object_type) {
	BunnyShould* self = NULL;
	self = (BunnyShould*) g_type_create_instance (object_type);
	return self;
}


BunnyShould* bunny_should_new (void) {
	return bunny_should_construct (BUNNY_TYPE_SHOULD);
}


static void bunny_value_should_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void bunny_value_should_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		bunny_should_unref (value->data[0].v_pointer);
	}
}


static void bunny_value_should_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = bunny_should_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer bunny_value_should_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* bunny_value_should_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		BunnyShould* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = bunny_should_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* bunny_value_should_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	BunnyShould** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = bunny_should_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* bunny_param_spec_should (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	BunnyParamSpecShould* spec;
	g_return_val_if_fail (g_type_is_a (object_type, BUNNY_TYPE_SHOULD), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer bunny_value_get_should (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_SHOULD), NULL);
	return value->data[0].v_pointer;
}


void bunny_value_set_should (GValue* value, gpointer v_object) {
	BunnyShould* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_SHOULD));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BUNNY_TYPE_SHOULD));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		bunny_should_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bunny_should_unref (old);
	}
}


void bunny_value_take_should (GValue* value, gpointer v_object) {
	BunnyShould* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BUNNY_TYPE_SHOULD));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BUNNY_TYPE_SHOULD));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bunny_should_unref (old);
	}
}


static void bunny_should_class_init (BunnyShouldClass * klass) {
	bunny_should_parent_class = g_type_class_peek_parent (klass);
	((BunnyShouldClass *) klass)->finalize = bunny_should_finalize;
}


static void bunny_should_instance_init (BunnyShould * self) {
	self->ref_count = 1;
}


static void bunny_should_finalize (BunnyShould* obj) {
	BunnyShould * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BUNNY_TYPE_SHOULD, BunnyShould);
	g_signal_handlers_destroy (self);
}


/**
     *    Should
     */
GType bunny_should_get_type (void) {
	static volatile gsize bunny_should_type_id__volatile = 0;
	if (g_once_init_enter (&bunny_should_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { bunny_value_should_init, bunny_value_should_free_value, bunny_value_should_copy_value, bunny_value_should_peek_pointer, "p", bunny_value_should_collect_value, "p", bunny_value_should_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (BunnyShouldClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bunny_should_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BunnyShould), 0, (GInstanceInitFunc) bunny_should_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType bunny_should_type_id;
		bunny_should_type_id = g_type_register_fundamental (g_type_fundamental_next (), "BunnyShould", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&bunny_should_type_id__volatile, bunny_should_type_id);
	}
	return bunny_should_type_id__volatile;
}


gpointer bunny_should_ref (gpointer instance) {
	BunnyShould* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void bunny_should_unref (gpointer instance) {
	BunnyShould* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		BUNNY_SHOULD_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



